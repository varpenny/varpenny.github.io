{"meta":{"title":"Penny 的笔记本","subtitle":"各种随笔，巴啦啦能量，搬砖技能杂货店","description":"各种随笔，巴啦啦能量，搬砖技能杂货店","author":"Penny","url":"http://www.varpenny.com"},"pages":[{"title":"关于","date":"2018-02-25T06:14:18.000Z","updated":"2018-02-25T06:14:18.000Z","comments":false,"path":"about/index.html","permalink":"http://www.varpenny.com/about/index.html","excerpt":"","text":"搬得了砖弹得了琴，女汉子中的伪文艺；天生居家却不安分，深藏一颗流浪的心。"},{"title":"分类","date":"2018-02-25T05:49:41.000Z","updated":"2018-02-24T01:56:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.varpenny.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2018-02-25T05:49:41.000Z","updated":"2018-02-24T01:56:00.000Z","comments":false,"path":"books/index.html","permalink":"http://www.varpenny.com/books/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-02-25T06:31:42.000Z","updated":"2018-02-25T06:31:42.000Z","comments":false,"path":"repository/index.html","permalink":"http://www.varpenny.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-02-25T05:49:42.000Z","updated":"2018-02-24T01:56:00.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.varpenny.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mac 使用技巧","slug":"Mac使用技巧","date":"2017-05-21T13:27:40.000Z","updated":"2018-02-25T09:06:20.000Z","comments":true,"path":"posts/Mac使用技巧.html","link":"","permalink":"http://www.varpenny.com/posts/Mac使用技巧.html","excerpt":"键盘党来发福利啦，不定期更新。","text":"键盘党来发福利啦，不定期更新。特别说明cmd: commandopt: optiondel: deletectrl: controlspace: 空格键power: 电源键down: 向下箭头up: 向上箭头系统关机：ctrl + opt + cmd + power重启：ctrl + cmd + power睡眠：opt + cmd + power打开文件：cmd + O退出应用：cmd + Q打开强制关闭应用选项：opt + cmd + esc切换应用：cmd + tab (+ shift 反向切换)切换应用窗口：cmd + `隐藏窗口：cmd + H最小化窗口：cmd + M全屏：ctrl + cmd + F浏览器放大／缩小页面：cmd + + / cmd + -新建／关闭标签页：cmd + T / cmd + W新建浏览器窗口：cmd + N刷新页面：cmd + R页面内查找：cmd + F最大化浏览器窗口：双击标签栏空白处（Chrome 浏览器 + shift ）文件删除文件：cmd + del（在 Finder 中执行）恢复文件：cmd + del（在 Trash 废纸篓中执行）清空废纸篓：shift + cmd + delete（+ opt 则直接清空不询问确认）显示文件简介：cmd + I新建文件夹：cmd + N文件重命名：enter进入／退出文件夹目录：cmd + down / cmd + up截图截取整个屏幕：shift + cmd + 3截取鼠标选择的区域：shift + cmd + 4截取应用窗口的区域：shift + cmd + 4 + space截图保存在剪切板：以上快捷键 + control（以上截图默认保存在桌面）输入复制／粘贴：cmd + C / cmd + V撤销／恢复：cmd + Z / shift + cmd + Z (Sublime Text 还支持 cmd + Y)保存／另存为：cmd + S / shift + cmd + S选择全部：cmd + A打印：cmd + P切换中英文输入法：cmd + space选择输入特殊符号：shift + opt + B（需在中文输入法状态下）其他在 Finder 标题栏中始终显示(YES)／隐藏(NO)当前全路径：在终端执行（执行后 Finder 会自动重启）1defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES &amp;&amp; killall Finder在 Finder 中始终显示(YES)／不显示(NO)隐藏文件：在终端执行（执行后 Finder 会自动重启）1defaults write com.apple.finder AppleShowAllFiles -bool YES &amp;&amp; killall Finder校验 SHA1：在终端执行1openssl sha1 [full path to file]使用键盘来操作（切换、选择）各种提示框的选项：(1) 在系统快捷键设置中，允许 tab 键在所有控制面板中切换焦点(2) 操作时，通过 tab 键切换选项，按下 space 键选择当前焦点选项（蓝色边框），按下 enter 键选择默认选项（蓝色背景）开机自动启动应用System Preferences -&gt; Users &amp; Groups -&gt; Login ItemsTerminal 计算机名显示 bogon，可设置让其始终显示自己设置的计算机名123sudo hostname your-desired-host-namesudo scutil --set LocalHostName $(hostname)sudo scutil --set HostName $(hostname)终端主机名显示 bogan123sudo hostname your-desired-host-namesudo scutil --set LocalHostName $(hostname)sudo scutil --set HostName $(hostname)","categories":[{"name":"生活","slug":"life","permalink":"http://www.varpenny.com/categories/life/"}],"tags":[{"name":"工具","slug":"tool","permalink":"http://www.varpenny.com/tags/tool/"},{"name":"办公","slug":"office","permalink":"http://www.varpenny.com/tags/office/"}]},{"title":"Git 备忘录","slug":"Git备忘录","date":"2017-05-07T09:39:03.000Z","updated":"2018-02-25T08:59:32.000Z","comments":true,"path":"posts/Git备忘录.html","link":"","permalink":"http://www.varpenny.com/posts/Git备忘录.html","excerpt":"好记性不如烂笔头，烂记性只好靠笔头。","text":"好记性不如烂笔头，烂记性只好靠笔头。常用命令重命名 tag (v1.0.11 -&gt; 1.0.11)1234git tag 1.0.11 v1.0.11git push --tagsgit tag -d v1.0.11git push origin :refs/tags/v1.0.11代码提交统计1git log --author=&quot;$(git config user.name)&quot; --until=&quot;2017-04-11&quot; --pretty=tformat: --numstat | gawk &apos;&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf &quot;Added lines: %s \\nRemoved lines: %s \\nTotal lines: %s\\n&quot;, add, subs, loc &#125;&apos; -选择性合并分支目录／文件将 release 分支的 /app 目录合并到 master12git checkout mastergit checkout release app撤销与恢复撤销到上一个版本：12git reset --hard HEAD^git reset --hard HEAD~1 // 或撤销到指定版本：12git loggit reset --hard &lt;commit&gt;恢复撤销到上一个版本：1git reset --hard HEAD@&#123;1&#125;恢复撤销到指定版本：12git refloggit reset --hard &lt;commit&gt;删除分支删除本地分支：12$ git branch -d &lt;branch_name&gt; // $ git branch -D &lt;branch_name&gt; // 或删除远程分支：1$ git push -d &lt;remote_name&gt; &lt;branch_name&gt;","categories":[{"name":"开发","slug":"development","permalink":"http://www.varpenny.com/categories/development/"}],"tags":[{"name":"工具","slug":"tool","permalink":"http://www.varpenny.com/tags/tool/"}]},{"title":"自定义域名的那些事儿","slug":"自定义域名的那些事儿","date":"2017-02-04T07:35:52.000Z","updated":"2018-02-25T09:12:51.000Z","comments":true,"path":"posts/自定义域名的那些事儿.html","link":"","permalink":"http://www.varpenny.com/posts/自定义域名的那些事儿.html","excerpt":"关于域名，看看 Wiki 老师怎么说：域名是一个在互联网中规定行政自治、权利或控制领域的标识字符串，被 DNS（域名系统） 将其与 IP 地址相互映射起来，用于 Web 访问时标识目标位置。其中，DNS 类似一个电话簿，域名好比联系人名称，IP 地址对应联系人的电话号码。如此一来，相比于晦涩难记的 IP 地址，用户只需要记住通俗易懂的域名即可。","text":"关于域名，看看 Wiki 老师怎么说：域名是一个在互联网中规定行政自治、权利或控制领域的标识字符串，被 DNS（域名系统） 将其与 IP 地址相互映射起来，用于 Web 访问时标识目标位置。其中，DNS 类似一个电话簿，域名好比联系人名称，IP 地址对应联系人的电话号码。如此一来，相比于晦涩难记的 IP 地址，用户只需要记住通俗易懂的域名即可。关于域名的级别，这里举个栗子，以 www.wikipedia.org 这个域名为例，简要说明一下：org 顶级域名，或称一级域名，类似的还有 com、net、edu 等wikipedia 二级域名，指定 wikipedia.org 作为 org 的字域名www 主机名，指定使用的是 www（万维网） 这个主机服务，类似的还有 ftp、mail 等域名注册这里仅针对一些用于个人网站自定义域名而注册的域名，通常是形如 xxx.com 的二级域名，根据许多人推荐在 GoDaddy 购买和注册，注册成功后，均可在 WHOIS 系统查询到注册信息。自定义网站域名以在 GoDaddy 注册的域名和 Github Page 的博客为例，按以下步骤操作：在 Github 项目的根目录新建一个文件名大写且无后缀名的文件 CNAME，文件内容为设置的域名。如果填写的是 www.xxx.com，则访问 xxx.com 会重定向到 www.xxx.com，反之同理在 Godaddy 域名对应的 DNS 管理页面(1) 添加两条 A 记录，目的是将自己的域名映射到 192.30.252.153 和 192.30.252.154 这两个 IP 地址(2) 添加一条 CNAME 记录，目的是将自己的域名作为 Github Page 博客域名的别名，注意如果 CNAME 类型列表已有 www 主机设置，则直接修改对应的以上均设置成功之后，就只等 DNS 散布出去了，我的情况是等了不到 2h（没统计具体时间） 就能查询并访问了。可在终端通过 dig 命令查看 DNS 是否已生效：1dig varpenny.com +nostats +nocomments +nocmd参考资料[1] https://en.wikipedia.org/wiki/Domain_name[2] https://en.wikipedia.org/wiki/Hostname[3] https://help.github.com/articles/setting-up-an-apex-domain-and-www-subdomain/","categories":[{"name":"网络","slug":"network","permalink":"http://www.varpenny.com/categories/network/"}],"tags":[{"name":"手册","slug":"manual","permalink":"http://www.varpenny.com/tags/manual/"}]},{"title":"浅谈浏览器 HTTP 的缓存机制","slug":"浅谈浏览器HTTP的缓存机制","date":"2016-10-16T07:35:33.000Z","updated":"2018-02-25T08:54:15.000Z","comments":true,"path":"posts/浅谈浏览器HTTP的缓存机制.html","link":"","permalink":"http://www.varpenny.com/posts/浅谈浏览器HTTP的缓存机制.html","excerpt":"本文来自转载，原文请戳这里。针对浏览器的http缓存的分析也算是老生常谈了，每隔一段时间就会冒出一篇不错的文章，其原理也是各大公司面试时几乎必考的问题。","text":"本文来自转载，原文请戳这里。针对浏览器的http缓存的分析也算是老生常谈了，每隔一段时间就会冒出一篇不错的文章，其原理也是各大公司面试时几乎必考的问题。之所以还写一篇这样的文章，是因为近期都在搞新技术，想“回归”下基础，也希望尽量总结的更详尽些。那么你是否还需要阅读本篇文章呢？可以试着回答下面这个问题：我们在访问百度首页的时候，会发现不管怎么刷新页面，静态资源基本都是返回 200（from cache）：随便点开一个静态资源是酱的：哎哟有Response报头数据呢，看来服务器也正常返回了etag什么鬼的应有尽有，那状态200不是应该对应的非缓存状态么？要from cache的话不是应该返回304才合理么？难道是度娘的服务器故障了吗？如果你知道答案，那就可以忽略本文了。http报文中与缓存相关的首部字段我们先来瞅一眼RFC2616规定的47种http报文首部字段中与缓存相关的字段，事先了解一下能让咱在心里有个底：通用首部字段（就是请求报文和响应报文都能用上的字段）请求首部字段响应首部字段实体首部字段后续大体也会依次介绍它们。场景模拟为方便模拟各种缓存效果，我们建个非常简单的场景。1、页面文件我们建个非常简单的html页面，上面只有一个本地样式文件和图片：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;缓存测试&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"css/reset.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;哥只是一个标题&lt;/h1&gt;&lt;p&gt;&lt;img src=\"img/dog.jpg\" /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;2、首部字段修改有时候一些浏览器会自行给请求首部加上一些字段（如chrome使用F5会强制加上“cache-control:max-age=0”）,会覆盖掉一些字段（比如pragma）的功能；另外有时候我们希望服务器能多/少返回一些响应字段。这种情况我们就希望可以手动来修改请求或响应报文上的内容了。那么如何实现呢？这里我们使用Fiddler来完成任务。在Fiddler中我们可以通过“bpu XXX”指令来拦截指定请求，然后手动修改请求内容再发给服务器、修改响应内容再发给客户端。以我们的example为例，页面文件走nginx通过 http://localhost/ 可直接访问，所以我们直接执行“bpu localhost”拦截所有地址中带有该字样的请求：点击被拦截的请求，可以在右栏直接修改报文内容（上半区域是请求报文，下半区域是响应报文），点击黄色的“Break on Response”按钮可以执行下一步（把请求发给服务器），点击绿色的按钮“Run to Completion”可以直接完成整个请求过程：通过这个方法我们可以很轻松地模拟出各种http缓存场景。3、浏览器的强制策略如上述，当下大多数浏览器在点击刷新按钮或按F5时会自行加上“Cache-Control:max-age=0”请求字段，所以我们先约定成俗——后文提及的“刷新”多指的是选中url地址栏并按回车键（这样不会被强行加上Cache-Control）。事实上有的浏览器还有一些更奇怪的行为，在后续我们回答文章开头问题的时候会提到。石器时代的缓存方式在 http1.0 时代，给客户端设定缓存方式可通过两个字段——“Pragma”和“Expires”来规范。虽然这两个字段早可抛弃，但为了做http协议的向下兼容，你还是可以看到很多网站依旧会带上这两个字段。1、Pragma当该字段值为“no-cache”的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上这段meta元标签（而且可能还得做些hack放到body后面去：1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt;它告诉浏览器每次请求页面时都不要读缓存，都得往服务器发一次请求才行。BUT!!! 事实上这种禁用缓存的形式用处很有限：12仅有IE才能识别这段meta标签含义，其它主流浏览器仅能识别“Cache-Control: no-store”的meta标签（见[出处](http://securityevaluators.com/knowledge/case_studies/caching/)）。在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。做了测试后发现也的确如此，这种客户端定义Pragma的形式基本没起到多少作用。不过如果是在响应报文上加上该字段就不一样了：如上图红框部分是再次刷新页面时生成的请求，这说明禁用缓存生效，预计浏览器在收到服务器的Pragma字段后会对资源进行标记，禁用其缓存行为，进而后续每次刷新页面均能重新发出请求而不走缓存。2、Expires有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http1.0而言，Expires就是做这件事的首部字段。Expires的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2002 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。在客户端我们同样可以使用meta标签来知会IE（也仅有IE能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间：1&lt;meta http-equiv=\"expires\" content=\"mon, 18 apr 2016 14:30:00 GMT\"&gt;如果希望在IE下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把“content”里的值写为“-1”或“0”。注意的是该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间：在上图里，缓存时间设置为一个已过期的时间点（见红框），则刷新页面将重新发送请求（见蓝框）。那么如果Pragma和Expires一起上阵的话，听谁的？我们试一试就知道了：我们通过Pragma禁用缓存，又给Expires定义一个还未到期的时间（红框），刷新页面时发现均发起了新请求（蓝框），这意味着Pragma字段的优先级会更高。BUT，响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。Cache-Control针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间，若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准。Cache-Control也是一个通用首部字段，这意味着它能分别在请求报文和响应报文中使用。在RFC中规范了 Cache-Control 的格式为：1Cache-Control: cache-directive作为请求首部时，cache-directive 的可选值有：作为响应首部时，cache-directive 的可选值有：我们依旧可以在HTML页面加上meta标签来给请求报头加上 Cache-Control 字段另外 Cache-Control 允许自由组合可选值，例如：1Cache-Control: max-age=3600, must-revalidate它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。当然这种组合的方式也会有些限制，比如 no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用。组合的形式还能做一些浏览器行为不一致的兼容处理。例如在IE我们可以使用 no-cache 来防止点击“后退”按钮时页面资源从缓存加载，但在 Firefox 中，需要使用 no-store 才能防止历史回退时浏览器不从缓存中去读取数据，故我们在响应报头加上如下组合值即可做兼容处理：1Cache-Control: no-cache, no-store缓存校验字段上述的首部字段均能让客户端决定是否向服务器发送请求，比如设置的缓存时间未过期，那么自然直接从本地缓存取数据即可（在chrome下表现为200 from cache），若缓存时间过期了或资源不该直接走缓存，则会发请求到服务器去。我们现在要说的问题是，如果客户端向服务器发了请求，那么是否意味着一定要读取回该资源的整个实体内容呢？我们试着这么想——客户端上某个资源保存的缓存时间过期了，但这时候其实服务器并没有更新过这个资源，如果这个资源数据量很大，客户端要求服务器再把这个东西重新发一遍过来，是否非常浪费带宽和时间呢？答案是肯定的，那么是否有办法让服务器知道客户端现在存有的缓存文件，其实跟自己所有的文件是一致的，然后直接告诉客户端说“这东西你直接用缓存里的就可以了，我这边没更新过呢，就不再传一次过去了”。为了让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，Http1.1新增了几个首部字段来做这件事情。1、Last-Modified服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可。至于传递标记起来的最终修改时间的请求报文首部字段一共有两个：⑴ If-Modified-Since: Last-Modified-value1示例为 If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。⑵ If-Unmodified-Since: Last-Modified-value告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed) 状态码给客户端。当遇到下面情况时，If-Unmodified-Since 字段会被忽略：123Last-Modified值对上了（资源在服务端没有新的修改）；服务端需返回2XX和412之外的状态码；传来的指定日期不合法Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。2、ETag为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了 ETag 实体首部字段。服务器会通过某种算法，给资源计算得出一个唯一标志符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上“ETag: 唯一标识符”一起返回给客户端。客户端会保留该 ETag 字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。那么客户端是如何把标记在资源上的 ETag 传去给服务器的呢？请求报文中有两个首部字段可以带上 ETag 值：⑴ If-None-Match: ETag-value1示例为 If-None-Match: \"56fcccc8-1699\"告诉服务端如果 ETag 没匹配上需要重发资源数据，否则直接回送304 和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的 ETag 值。⑵ If-Match: ETag-value告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。If-Match 的一个应用场景是，客户端走PUT方法向服务端请求上传/更替资源，这时候可以通过 If-Match 传递资源的ETag。需要注意的是，如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上计算ETag唯一值的算法保持一致，才不会导致明明同一个文件，在服务器A和服务器B上生成的ETag却不一样。如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。在较新的 nginx 上默认是同时开启了这两个功能的：上图的前三条请求是原始请求，接着的三条请求是刷新页面后的新请求，在发新请求之前我们修改了 reset.css 文件，所以它的 Last-Modified 和 ETag 均发生了改变，服务器因此返回了新的文件给客户端（状态值为200）。而 dog.jpg 我们没有做修改，其Last-Modified 和 ETag在服务端是保持不变的，故服务器直接返回了304状态码让客户端直接使用缓存的 dog.jpg 即可，没有把实体内容返回给客户端（因为没必要）。缓存实践当我们在一个项目上做http缓存的应用时，我们还是会把上述提及的大多数首部字段均使用上，例如使用 Expires 来兼容旧的浏览器，使用 Cache-Control 来更精准地利用缓存，然后开启 ETag 跟 Last-Modified 功能进一步复用缓存减少流量。那么这里会有一个小问题——Expires 和 Cache-Control 的值应设置为多少合适呢？答案是不会有过于精准的值，均需要进行按需评估。例如页面链接的请求常规是无须做长时间缓存的，从而保证回退到页面时能重新发出请求，百度首页是用的 Cache-Control:private，腾讯首页则是设定了60秒的缓存，即 Cache-Control:max-age=60。而静态资源部分，特别是图片资源，通常会设定一个较长的缓存时间，而且这个时间最好是可以在客户端灵活修改的。以腾讯的某张图片为例：1http://i.gtimg.cn/vipstyle/vipportal/v4/img/common/logo.png?max_age=2592000客户端可以通过给图片加上“max_age”的参数来定义服务器返回的缓存时间：当然这需要有一个前提——静态资源能确保长时间不做改动。如果一个脚本文件响应给客户端并做了长时间的缓存，而服务端在近期修改了该文件的话，缓存了此脚本的客户端将无法及时获得新的数据。解决该困扰的办法也简单——把服务侧ETag的那一套也搬到前端来用——页面的静态资源以版本形式发布，常用的方法是在文件名或参数带上一串md5或时间标记符：123https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26http://tb1.bdstatic.com/tb/_/tbean_safe_ajax_94e7ca2.jshttp://img1.gtimg.com/ninja/2/2016/04/ninja145972803357449.jpg如果文件被修改了，才更改其标记符内容，这样能确保客户端能及时从服务器收取到新修改的文件。关于开头的问题现在回过头来看文章开头的问题，可能会觉得答案很容易回答出来。百度首页的资源在刷新后实际没有发送任何请求，因为 Cache-Control 定义的缓存时间段还没到期。在Chrome中即使没发送请求，但只要从本地的缓存中取，都会在Network面板显示一条状态为200且注明“from cache”的伪请求，其Response内容只是上一次回包留下的数据。然而这并不是问题的全部答案，我们前面提到过，在Chrome中如果点击“刷新”按钮，Chrome会强制给所有资源加上“Cache-Control: max-age=0”的请求首部并向服务器发送验证请求的，而在文章开头的动图中，我们的确点击了“刷新”按钮，却不见浏览器发去新请求（并返回304）。关于这个问题其实在组内跟小伙伴们讨论过，通过Fiddler抓包发现，如果关闭Chrome的开发者面板再点击“刷新”按钮，浏览器是会按预期发送验证请求且接收返回的304响应的，另外这个奇怪的情况在不同的网站甚至不同的电脑下出现频率都不一致，所以暂时将其归咎于浏览器的怪异反应。那么有这么一个问题——是否有办法在浏览器点击“刷新”按钮的时候不让浏览器去发新的验证请求呢？办法还是有的，就是不怎么实用——在页面加载完毕后通过脚本动态地添加资源：123456$(window).load(function() &#123; var bg='http://img.infinitynewtab.com/wallpaper/100.jpg'; setTimeout(function() &#123; //setTimeout是必须的 $('#bgOut').css('background-image', 'url('+bg+')'); &#125;,0);&#125;);出处来自知乎，更具体的解释可以去看看。其它相关的首部字段事实上较常用和重要的缓存相关字段我们都介绍完了，这里顺带讲讲几个跟缓存有关系，但没那么主要的响应首部字段。1、Vary“vary”本身是“变化”的意思，而在http报文中更趋于是“vary from”（与。。。不同）的含义，它表示服务端会以什么基准字段来区分、筛选缓存版本。我们先考虑这么一个问题——在服务端有着这么一个地址，如果是IE用户则返回针对IE开发的内容，否则返回另一个主流浏览器版本的内容。这很简单，服务端获取到请求的 User-Agent 字段做处理即可。但是用户请求的是代理服务器而非原服务器，且代理服务器如果直接把缓存的IE版本资源发给了非IE的客户端，这就出问题了。因此 Vary 便是着手处理该问题的首部字段，我们可以在响应报文加上：1Vary: User-Agent便能知会代理服务器需要以 User-Agent 这个请求首部字段来区别缓存版本，防止传递给客户端的缓存不正确。Vary 也接受条件组合的形式：1Vary: User-Agent, Accept-Encoding这意味着服务器应以 User-Agent 和 Accept-Encoding 两个请求首部字段来区分缓存版本。2、Date 和 AgeHTTP并没有提供某种方法来帮用户区分其收到的资源是否命中了代理服务器的缓存，但在客户端我们可以通过计算响应报文中的 Date 和 Age 字段来得到答案。Date 理所当然是原服务器发送该资源响应报文的时间（GMT格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续F5刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。上述的“当前时间”自然是相对于原服务器而言的时间，那么如何获悉原服务器的当前时间呢？常规从页面地址请求的响应报文中可获得，以博客园首页为例：每次你刷新页面，浏览器都会重新发出这条url的请求，你会发现其 Date 值是不断变化的，这说明该链接没有命中缓存，都是从原服务器返回过来的数据。因此我们可以拿页面上其它静态资源请求回包中的 Date 与其进行对比，若静态资源的 Date 早于原服务端时间，则说明命中了代理服务器缓存。通常还满足这么个条件：1静态资源Age + 静态资源Date = 原服务端Date这里的 Age 也是响应报文中的首部字段，它表示该文件在代理服务器中存在的时间（秒），如文件被修改或替换，Age会重新由0开始累计。我们在上面那张博客园首页报文截图的同个场景下，看看某个文件（jQuery.js）命中代理服务器缓存的回包数据：会发现它满足我们上述的规则：12//return truenew Date('Mon, 04 Apr 2016 07:03:17 GMT')/1000 == new Date('Sat, 19 Dec 2015 01:29:14 GMT')/1000 + 9264843不过这条规则也不一定准确，特别是当原服务器经常修改系统时间的情况下。关于http缓存原理的知识就整理到这，希望能让你有所收获，共勉~","categories":[{"name":"开发","slug":"development","permalink":"http://www.varpenny.com/categories/development/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.varpenny.com/tags/HTTP/"},{"name":"浏览器","slug":"browser","permalink":"http://www.varpenny.com/tags/browser/"}]},{"title":"URL、URI 和 URN 之间的关系","slug":"URL-URI和URN之间的关系","date":"2016-10-15T07:35:18.000Z","updated":"2018-02-25T09:14:24.000Z","comments":true,"path":"posts/URL-URI和URN之间的关系.html","link":"","permalink":"http://www.varpenny.com/posts/URL-URI和URN之间的关系.html","excerpt":"如今，网址 (URL) 这个词儿对很多普通大众来说都不会陌生。那么，URI 和 URN 是啥玩意儿呢？跟 URL 有啥亲戚关系么？","text":"如今，网址 (URL) 这个词儿对很多普通大众来说都不会陌生。那么，URI 和 URN 是啥玩意儿呢？跟 URL 有啥亲戚关系么？基本概念Wiki 老师说：URI (Uniform Resource Identifier 统一资源标志符): 用于标识资源的字符串URL (Uniform Resource Locator 统一资源定位符): 用于提供事物位置及获取的方法，是 URI 最常见的一种形式URN (Uniform Resource Name 统一资源名称): 用于定义事物的身份并具有唯一性，旨在通过提供一种识别指定命名空间下资源的途径（标识）以补充 URL然后，用咱理科生的思维 po 一张通俗易懂的图来阐明三者的关系：由图可见，URL 和 URN 一定是 URI，但 URI 不一定是 URL 或 URN。栗子栗子麻烦来一盘栗子谢谢：既不是 URL 也不是 URN 的 URI：1234data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD///+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4Ug9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCCURL（也是 URI）：1mailto:varpenny@gmail.comURN（也是 URI）：1urn:isbn:978-7-5641-2940-8URI 中 URL 和 URN 各自的部分：参考资料[1] https://prateekvjoshi.com/2014/02/22/url-vs-uri-vs-urn/[2] http://webmasters.stackexchange.com/questions/19101/what-is-the-difference-between-a-uri-and-a-url","categories":[{"name":"网络","slug":"network","permalink":"http://www.varpenny.com/categories/network/"}],"tags":[]},{"title":"HTTP 状态码","slug":"HTTP状态码","date":"2016-09-21T11:00:20.000Z","updated":"2018-02-25T08:54:16.000Z","comments":true,"path":"posts/HTTP状态码.html","link":"","permalink":"http://www.varpenny.com/posts/HTTP状态码.html","excerpt":"HTTP 状态码，顾名思义，就是 HTTP 请求后用来表示响应状态的代码，由3位数字组合而成。","text":"HTTP 状态码，顾名思义，就是 HTTP 请求后用来表示响应状态的代码，由3位数字组合而成。其中，左边第1位数字表明响应状态分类：1xx: 消息2xx: 成功3xx: 重定向4xx: 客户端错误5xx: 服务器端错误常见的 HTTP 状态码200 OK: 请求已成功（这个最常见了吧）301 Moved Permanently: 永久移动到新的位置，通俗的说，就是请求的 URL 已更改为新的 URL，如图：302 Found: 请求的资源现在临时从不同的 URI 响应请求（临时移动／Moved Temporarily）303 See Other: HTTP/1.1 新增的，与 302 几乎一样，区别在于这个响应会让浏览器针对新的位置发起始终是 GET 方式的请求304 Not Modified: 请求的资源与客户端缓存对比没有修改307 Temporary Redirect: HTTP/1.1 新增的，与 302 几乎一样，区别在于这个响应会让浏览器在下一个请求中使用相同的请求方式发送到最新的位置403 Forbidden: 请求被拒绝访问404 Not Found: 请求失败，请求的资源未在服务器上找到412 Precondition Failed: 服务器在验证请求头字段中给出先决条件时，没能满足其中的一个或多个，常见于 If-Unmodified-Since、If-Match 等缓存校验字段500 Internal Server Error: 服务器端的代码出错了赶紧改 Bug502 Bad Gateway: 网关或代理服务器在请求上游服务器时没有收到有效响应此外，还有部分非 RFC 官方指定的状态码，用于一些第三方服务以提供语义或 RESTful 错误的响应参考资料[1] https://en.wikipedia.org/wiki/List_of_HTTP_status_codes","categories":[{"name":"网络","slug":"network","permalink":"http://www.varpenny.com/categories/network/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://www.varpenny.com/tags/HTTP/"}]},{"title":"浏览器兼容问题之 IE","slug":"浏览器兼容问题之IE","date":"2016-09-18T07:34:50.000Z","updated":"2018-02-25T08:52:35.000Z","comments":true,"path":"posts/浏览器兼容问题之IE.html","link":"","permalink":"http://www.varpenny.com/posts/浏览器兼容问题之IE.html","excerpt":"为了方便查阅，于是整理出（不定期更新）这么一个关于 IE 兼容问题的小（大）锦（杂）囊（烩），不求面面俱到，但求简单粗暴。","text":"为了方便查阅，于是整理出（不定期更新）这么一个关于 IE 兼容问题的小（大）锦（杂）囊（烩），不求面面俱到，但求简单粗暴。让人抓狂的 IE6伪类选择器 :hover 仅针对 a 元素（设置有的 href 属性）有效，因此很多时候需要额外嵌套该标签来支持，另可改用 JS 侦听鼠标事件来增删 class 实现。此外，当 a 元素 position: relative;，子元素 position: absolute; 且默认隐藏 hover 显示，需要在 hover 时设置 _background: none; 或 _zoom: 1; 等触发 hasLayout 才会正常显示。不支持 .class1.class2 多类选择器（实际效果等同于 .class2）、子元素选择器、属性选择器双边距问题，即在浮动方向设置了对应的 margin（如 float: left; margin-left: 10px;） 会出现实际边距是设定值的两倍（margin-left: 20px），需要通过设置 _display: inline; 来解决。position: fixed; 元素在滚动页面过程中会出现抖动问题，解决方案栗子如下：1234567891011html, body &#123; _background-image: url(about:blank); _background-attachment: fixed;&#125;.fixed &#123; position: fixed; left: 100px; top: 100px; _position: absolute; _margin-top: expression(documentElement.scrollTop);&#125;png24 图片透明部分呈灰色，目前有 DD_belatedPNG.js 插件可以很好地处理这个问题，另有 CSS 解决方案栗子如下：1234.png24 &#123; _background: none; _filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=scale, src='images/png24.png');&#125;注意，该方案不支持 background-position 和 background-repeat 属性，且会导致子元素 a 失效（可对子元素 a 定位且元素本身不定位来解决）。子元素浮动父元素不浮动时，其他浏览器可通过设置 overflow: hidden; 撑开父元素高度，但 IE6 需要额外设置 _zoom: 1; 以触发 hasLayout 才正确。height 属性对 select 元素无效还是一个衰样的 IE7input 元素设置 border: none; 无效，需要设置 *border: 0;。元素定宽高且 overflow: hidden; 不会隐藏 position: relative; 的子元素。行内元素浮动，位于行末的元素内部文字会通过折行以保证该元素在行末放置得下，可通过设置 white-space: nowrap; 解决。实现 inline-block 元素，需要如下设置：12345.inline-block &#123; display: inline-block; *display: inline; *zoom: 1;&#125;块元素 position: absolute | fixed; 默认根据内容决定宽度，可通过 left: 0; right: 0; 独占一行宽度（IE6 需要定宽）。ul 元素浮动 li 元素不浮动，li 元素会产生左边距，可通过设置 li *float: left; 或 ul *list-style-position: outside; 解决。定位（即非 static）元素会同级比较层级，优先于 z-index。动态创建 script 标签来加载数据，设置 charset 的语句要在设值 src 语句之前执行，否则当涉及编码问题时，就不会执行回调函数。好不到哪儿去的 IE8支持 CSS2.1 的所有选择器，支持伪类，但是不支持如 :before、:after 等伪元素。不支持 opacity CSS 属性，需要通过滤镜实现：1234.class &#123; filter: alpha(opacity=60); opacity: 0.6;&#125;input 文本输入框默认不会垂直居中。JS 绑定事件，如 click 事件：12345if (elm.addEventListener) &#123; elm.addEventListener('click', fn);&#125; else &#123; elm.attachEvent &amp;&amp; obj.attachEvent('onclick', fn); // &lt;= IE8&#125;针对 window 对象的属性（Property）或方法（Method）执行 delete 操作，会抛出异常，需进行捕获操作：123456window['fnName'] = function() &#123;&#125;;try &#123; delete window['fnName'];&#125; catch &#123; window['fnName'] = undefined; // &lt;= IE8&#125;禁止事件冒泡：123456var e = window.event;if (e.stopPropagation) &#123; e.stopPropagation();&#125; else &#123; e.cancelBubble &amp;&amp; (e.cancelBubble = true); // &lt;= IE8&#125;不支持 document.head、document.getElementsByClassName(cls)、document.querySelectorAll 等原生 JS 属性和方法。还算省心的 IE9不支持 placeholder 属性存在即坑爹的 IE10无实体文字内容且 display: block; 的 a 元素块在 active 状态下有灰色背景，需要通过设置 background: none; 去掉我是萌萌哒分割线To be continue…","categories":[{"name":"开发","slug":"development","permalink":"http://www.varpenny.com/categories/development/"}],"tags":[{"name":"浏览器","slug":"browser","permalink":"http://www.varpenny.com/tags/browser/"},{"name":"兼容","slug":"compatibility","permalink":"http://www.varpenny.com/tags/compatibility/"}]},{"title":"Hello World","slug":"Hello-World","date":"2016-09-16T11:00:20.000Z","updated":"2018-02-25T09:13:34.000Z","comments":true,"path":"posts/Hello-World.html","link":"","permalink":"http://www.varpenny.com/posts/Hello-World.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[{"name":"开发","slug":"development","permalink":"http://www.varpenny.com/categories/development/"}],"tags":[{"name":"手册","slug":"manual","permalink":"http://www.varpenny.com/tags/manual/"}]}]}